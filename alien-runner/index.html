<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Alien Runner - Single File</title>
  <style>
    html, body { height: 100%; margin: 0; background: #fff; color: #000; }
    body { display: grid; place-items: center; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .wrap { display: flex; flex-direction: column; align-items: center; gap: 8px; }
    canvas { image-rendering: pixelated; border: 1px solid #000; background: #fff; touch-action: manipulation; }
    .controls { display: flex; gap: 8px; align-items: center; justify-content: center; }
    .btn { border: 1px solid #000; background: #fff; color: #000; padding: 6px 10px; cursor: pointer; }
    .hint { font-size: 12px; opacity: 0.8; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="800" height="250" aria-label="Endless runner game"></canvas>
    <div class="controls">
      <button id="retry" class="btn" disabled>Start</button>
      <span class="hint">Space/Click/Tap to jump</span>
    </div>
  </div>

  <script>
  // ===== Game constants =====
  const WIDTH = 800;
  const HEIGHT = 250;
  const GROUND_Y = 200;

  (() => {
    const canvas = document.getElementById('game');
    const retryBtn = document.getElementById('retry');
    const ctx = canvas.getContext('2d');

    const GRAVITY = 0.6;
    const JUMP_VELOCITY = -12;

    let state, rafId, startMs, frames, gameOver;
    let lastMs = 0;
    // Variable jump
    let holdJump = false;
    let holdMs = 0;
    const MAX_HOLD_MS = 220;
    // Audio
    let audioCtx = null, masterGain = null, musicGain = null, filter = null;
    let arpOsc = null, bassOsc = null;
    let arpTimer = null;
    let audioStarted = false;

    function reset() {
      state = {
        trex: { x: 50, y: GROUND_Y - 20, w: 20, h: 20, vy: 0, onGround: true },
        cacti: [],
        lastSpawn: 0,
        speed: 4,
        stars: initStars(),
        spawnCount: 0,
      };
      startMs = performance.now();
      lastMs = startMs;
      frames = 0;
      gameOver = false;
      retryBtn.disabled = true;
      holdJump = false;
      holdMs = 0;
      loop();
    }

    function jump() {
      if (gameOver) return;
      const t = state.trex;
      if (t.onGround) { t.vy = JUMP_VELOCITY; t.onGround = false; holdMs = 0; playJumpSfx(); }
    }

    function spawn(now) {
      const s = state;
      const elapsed = (now - startMs) / 1000;
      // Difficulty factor: 0 â†’ easy, ~1.0 at 60s, up to 1.5 cap
      const d = Math.min(1.5, Math.max(0, elapsed / 60));
      // Spawn interval ramps from relaxed to tighter over time
      let minInterval = lerp(1600, 700, Math.min(1, d));
      let maxInterval = lerp(2200, 1000, Math.min(1, d));
      // Easy onboarding: first 3 spawns are gentler and delayed
      if (s.spawnCount < 3) {
        minInterval = 1800;
        maxInterval = 2600;
      }
      // Enforce a minimum delay before the very first spawn
      const firstDelay = 1500; // ms
      if (s.spawnCount === 0 && (now - startMs) < firstDelay) return;
      const due = (now - s.lastSpawn) > (minInterval + Math.random() * (maxInterval - minInterval));
      if (due) {
        // Height variety grows over time
        let baseH = 18 + Math.floor(Math.random() * 14);
        const extra = Math.floor(Math.random() * Math.floor(10 * Math.min(1, d)));
        // Easier lower heights for first 3
        if (s.spawnCount < 3) baseH = 14 + Math.floor(Math.random() * 8);
        const h = baseH + extra;
        // Wider gaps early-on
        const gapRand = (s.spawnCount < 3)
          ? 140 + Math.floor(Math.random() * 220)
          : 80 + Math.floor(Math.random() * 180);
        s.cacti.push({ x: WIDTH + gapRand, y: GROUND_Y - h, w: 10, h });
        s.lastSpawn = now;
        s.spawnCount++;
      }
    }

    // ===== Audio helpers =====
    function initAudio() {
      if (audioCtx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new Ctx();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.5;
      masterGain.connect(audioCtx.destination);

      musicGain = audioCtx.createGain();
      musicGain.gain.value = 0.0;
      musicGain.connect(masterGain);

      filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 600;
      filter.Q.value = 0.7;
      filter.connect(musicGain);
    }

    function startMusic() {
      if (!audioCtx) initAudio();
      if (arpOsc || bassOsc) return;
      const ctx = audioCtx;

      // Bass bed
      bassOsc = ctx.createOscillator();
      bassOsc.type = 'square';
      const bassGain = ctx.createGain();
      bassGain.gain.value = 0.08;
      bassOsc.connect(bassGain).connect(filter);
      bassOsc.start();

      // Arp lead (square for chiptune flavor)
      arpOsc = ctx.createOscillator();
      arpOsc.type = 'square';
      const arpGain = ctx.createGain();
      arpGain.gain.value = 0.08;
      arpOsc.connect(arpGain).connect(filter);
      arpOsc.start();

      // Fade in
      musicGain.gain.cancelScheduledValues(ctx.currentTime);
      musicGain.gain.setTargetAtTime(0.35, ctx.currentTime, 0.5);

      scheduleArpTick();
    }

    function scheduleArpTick() {
      if (!audioCtx) return;
      if (arpTimer) { clearTimeout(arpTimer); arpTimer = null; }
      const elapsed = (performance.now() - startMs) / 1000;
      const baseBPM = 110; // more upbeat
      const tempoFactor = 1 + 0.6 * (1 - Math.exp(-elapsed / 45)); // gentle ramp
      const intervalMs = 60000 / (baseBPM * tempoFactor * 4); // sixteenth notes

      // Chiptune-friendly major-ish loop (G major-ish)
      const notes = [392.00, 494.88, 587.33, 494.88, 659.25, 587.33, 523.25, 440.00]; // G4 B4 D5 B4 E5 D5 C5 A4
      const bassNotes = [196.00, 147.00]; // G3, D3
      const n = Math.floor((performance.now() / intervalMs)) % notes.length;
      const b = Math.floor((performance.now() / (intervalMs * 8))) % bassNotes.length;
      const now = audioCtx.currentTime;

      // Mild brightness increase over time
      const cutoff = 1200 + 800 * (1 - Math.exp(-elapsed / 30));
      filter.frequency.cancelScheduledValues(now);
      filter.frequency.setTargetAtTime(cutoff, now, 0.08);

      if (arpOsc) arpOsc.frequency.setValueAtTime(notes[n], now);
      if (bassOsc) bassOsc.frequency.setValueAtTime(bassNotes[b], now);

      arpTimer = setTimeout(scheduleArpTick, intervalMs);
    }

    function ensureAudio() {
      if (audioStarted) { scheduleArpTick(); return; }
      audioStarted = true;
      try { initAudio(); startMusic(); } catch (e) { /* noop */ }
    }

    function playJumpSfx() {
      try {
        if (!audioCtx) initAudio();
        const ctx = audioCtx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        const now = ctx.currentTime;
        // Pitch sweep up for a snappy jump
        osc.frequency.setValueAtTime(520, now);
        osc.frequency.exponentialRampToValueAtTime(980, now + 0.08);
        gain.gain.setValueAtTime(0.0, now);
        gain.gain.linearRampToValueAtTime(0.35, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.16);
        osc.connect(gain).connect(masterGain || ctx.destination);
        osc.start(now);
        osc.stop(now + 0.18);
      } catch (e) { /* ignore */ }
    }

    function initStars() {
      const stars = [];
      for (let i = 0; i < 90; i++) {
        stars.push({
          x: Math.random() * WIDTH,
          y: Math.random() * HEIGHT,
          layer: 1 + Math.floor(Math.random() * 3), // 1..3
        });
      }
      return stars;
    }

    function lerp(a, b, t) { return a + (b - a) * t; }

    function aabb(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    function update(now) {
      // Speed ramp +0.5 every 30s
      const elapsed = (now - startMs) / 1000;
      state.speed = 4 + 0.5 * Math.floor(elapsed / 30);

      // Physics
      const t = state.trex;
      const dt = (now - lastMs) / 1000;
      lastMs = now;
      let g = GRAVITY;
      if (!t.onGround && t.vy < 0 && holdJump && holdMs < MAX_HOLD_MS) {
        g = 0.3; // reduced gravity while holding
        holdMs += dt * 1000;
      }
      t.vy += g;
      t.y += t.vy;
      if (t.y >= GROUND_Y - t.h) { t.y = GROUND_Y - t.h; t.vy = 0; t.onGround = true; }

      // Starfield parallax
      for (const s of state.stars) {
        const parallax = s.layer * 0.1;
        s.x -= parallax;
        if (s.x < 0) s.x += WIDTH;
      }

      // Obstacles
      spawn(now);
      for (const c of state.cacti) c.x -= state.speed;
      state.cacti = state.cacti.filter(c => c.x + c.w > 0);

      // Collision
      for (const c of state.cacti) {
        if (aabb(t, c)) {
          gameOver = true;
          retryBtn.disabled = false;
          retryBtn.textContent = 'Retry';
          cancelAnimationFrame(rafId);
          // soften music on game over
          if (musicGain && audioCtx) {
            const now = audioCtx.currentTime;
            musicGain.gain.cancelScheduledValues(now);
            musicGain.gain.setTargetAtTime(0.15, now, 0.2);
          }
          return;
        }
      }

      frames += 1;
    }

    function draw() {
      // Space background
      ctx.fillStyle = '#0a0d1a';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // Stars
      for (const s of state.stars) {
        if (s.layer === 1) ctx.fillStyle = '#444';
        else if (s.layer === 2) ctx.fillStyle = '#888';
        else ctx.fillStyle = '#fff';
        const size = s.layer === 3 ? 2 : 1;
        ctx.fillRect(Math.round(s.x), Math.round(s.y), size, size);
      }

      // Ground (platform line)
      ctx.strokeStyle = '#6ad1ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y + 0.5);
      ctx.lineTo(WIDTH, GROUND_Y + 0.5);
      ctx.stroke();

      // Player: pixel art alien within bounding box
      const t = state.trex;
      const px = Math.round(t.x), py = Math.round(t.y);
      const green = '#2bdc5a';
      const dark = '#0b0f24';
      // head (big)
      ctx.fillStyle = green;
      ctx.fillRect(px + 4, py + 1, 12, 4);
      ctx.fillRect(px + 3, py + 3, 14, 4);
      ctx.fillRect(px + 2, py + 5, 16, 4);
      ctx.fillRect(px + 3, py + 7, 14, 3);
      ctx.fillRect(px + 5, py + 9, 10, 2);
      // eyes (large black with white highlights)
      ctx.fillStyle = dark;
      ctx.fillRect(px + 6, py + 4, 4, 4);   // left eye
      ctx.fillRect(px + 12, py + 4, 4, 4);  // right eye
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(px + 7, py + 4, 1, 1);
      ctx.fillRect(px + 13, py + 4, 1, 1);
      // neck
      ctx.fillStyle = green;
      ctx.fillRect(px + 9, py + 10, 2, 2);
      // torso (rib-like segments)
      ctx.fillRect(px + 7, py + 12, 6, 2);
      ctx.fillRect(px + 6, py + 14, 8, 2);
      ctx.fillRect(px + 7, py + 16, 6, 2);
      // arms (thin)
      ctx.fillRect(px + 4, py + 13, 2, 5);  // left upper arm
      ctx.fillRect(px + 15, py + 13, 2, 5); // right upper arm
      // hands
      ctx.fillRect(px + 3, py + 18, 3, 2);
      ctx.fillRect(px + 14, py + 18, 3, 2);
      // legs (thin)
      ctx.fillRect(px + 8, py + 18, 2, 2);
      ctx.fillRect(px + 10, py + 18, 2, 2);

      // Obstacles: bright space debris
      ctx.fillStyle = '#ffffff';
      for (const c of state.cacti) {
        const cx = Math.round(c.x), cy = Math.round(c.y);
        // cluster look: main pillar plus a nub
        ctx.fillRect(cx, cy, c.w, c.h);
        ctx.fillRect(cx - 3, cy + Math.max(0, c.h - 10), 3, 6);
      }

      // HUD
      const score = Math.floor(frames / 10);
      ctx.fillStyle = '#e6ecff';
      ctx.font = '12px monospace';
      ctx.fillText(`Score: ${score}`, WIDTH - 120, 20);
      ctx.fillText(`Speed: ${state.speed.toFixed(1)}`, WIDTH - 120, 36);

      if (gameOver) {
        ctx.fillStyle = '#e6ecff';
        ctx.font = '16px monospace';
        const msg = 'Game Over - Press Enter or Retry';
        const w = ctx.measureText(msg).width;
        ctx.fillText(msg, (WIDTH - w) / 2, HEIGHT / 2);
      }
    }

    function loop(now) {
      update(now || performance.now());
      draw();
      if (!gameOver) rafId = requestAnimationFrame(loop);
    }

    // Input
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); ensureAudio(); if (!holdJump) jump(); holdJump = true; }
      if (e.code === 'Enter' && gameOver) { e.preventDefault(); reset(); }
    });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') holdJump = false; });
    canvas.addEventListener('mousedown', () => { ensureAudio(); if (!holdJump) jump(); holdJump = true; });
    window.addEventListener('mouseup', () => { holdJump = false; });
    canvas.addEventListener('mouseleave', () => { holdJump = false; });
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); ensureAudio(); if (!holdJump) jump(); holdJump = true; }, { passive: false });
    canvas.addEventListener('touchend', () => { holdJump = false; });
    canvas.addEventListener('touchcancel', () => { holdJump = false; });
    retryBtn.addEventListener('click', () => { if (gameOver) reset(); });

    // Start
    reset();
  })();
  </script>
</body>
</html>
